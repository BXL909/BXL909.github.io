<!-- 
 
2048 SATS by BXL909 - bxl909.github.io

-->

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>2048 Sats</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none; 
        }
        #particleCanvas {
            z-index: 1;
        }
        #gameCanvas {
            z-index: 2;
            pointer-events: auto; 
        }
        #logo {
            position: fixed;
            padding-bottom: 20px;
            z-index: 3;
            height: 200px;
        }
        #description {
            position: fixed;
            z-index: 3;
            margin: 0;
            padding-left: 20px;
            height: 200px; 
            background: rgba(26, 26, 26, 0.0);
        }
        #priceChart {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            padding-left: 20px;
            padding-bottom: 20px;
        }
        a {
            color: #FFA500;
            text-decoration: none;  
            transition: color 0.2s ease, text-decoration 0.2s ease;
        }
        a:hover {
            color: #FFB52E;  
            text-decoration: underline;
        }
        #bottomImage {
            height: 45px;  
            transition: transform 0.2s ease;
        }
        #bottomImage:hover {
            transform: scale(1.05);
        }
        .button-content {
            position: fixed;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .link {
            color: #FFA500;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        .link:hover {
            color: #FFB52E;
            text-decoration: underline;
        }
        .button-content p {
            margin: 0 !important;
            min-height: 3em !important;
            font-size: 24px !important;
            line-height: 1.4 !important;
            font-family: Arial !important;
        }
        @media not all and (pointer: coarse) {
            .button-content p {
                font-size: 14px !important;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script>
        async function updateVisitorCounter() {
            const visitorCounter = document.getElementById('visitorCounter');
            try {
                const response = await fetch('https://api.counterapi.dev/v1/bxl909/2048sats/up');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const result = await response.json();
                visitorCounter.textContent = result.count || '0'; 
            } catch (error) {
                console.error('CounterAPI error:', error.message);
                visitorCounter.textContent = 'Error';
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            updateVisitorCounter();
        });
    </script>
</head>
<body>
    <img id="logo" src="logo.png" alt="2048 Logo">
    <div id="description">
        <canvas id="priceChart"></canvas>
    </div>
    <canvas id="particleCanvas"></canvas>
    <canvas id="gameCanvas"></canvas>
    
    <div style="position: fixed; z-index: 1000; color: rgba(255, 255, 255, 0.8); font-family: Arial;">
        
        <label style="cursor: pointer;">
            <input type="checkbox" id="performanceMode"> PERFORMANCE MODE
        </label>
        <br><span style="font-size: 12px;">Player #<span id="visitorCounter">Loading...</span></span>

    </div>

    <script>
        const miniLogo = new Image();
        miniLogo.src = 'miniBXL909.png';

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        const particleCanvas = document.getElementById('particleCanvas');
        const gameCanvas = document.getElementById('gameCanvas');
        const pCtx = particleCanvas.getContext('2d');
        const gCtx = gameCanvas.getContext('2d');

        function resize() {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * particleCanvas.width;
                this.y = Math.random() * particleCanvas.height;
                this.size = Math.random() * 2 + 1;
                this.vx = (Math.random() - 0.5) * 1;
                this.vy = (Math.random() - 0.5) * 1;
                this.life = Math.random() * 200 + 200;
                this.maxLife = this.life;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                this.vx += (Math.random() - 0.5) * 0.1;
                this.vy += (Math.random() - 0.5) * 0.1;
                
                this.vx = Math.max(Math.min(this.vx, 1), -1);
                this.vy = Math.max(Math.min(this.vy, 1), -1);

                if (this.life <= 0 || 
                    this.x < 0 || this.x > particleCanvas.width ||
                    this.y < 0 || this.y > particleCanvas.height) {
                    this.reset();
                }
            }
        }

        const particles = Array(100).fill().map(() => new Particle());

        let performanceMode = false;
        const performanceCheckbox = document.getElementById('performanceMode');
        performanceCheckbox.addEventListener('change', (e) => {
            performanceMode = e.target.checked;
            if (performanceMode) {
                particleCanvas.style.display = 'none';
            } else {
                particleCanvas.style.display = 'block';
            }
        });

        function animate() {
            if (!performanceMode) {
                const time = Date.now() * 0.001;
                const width = particleCanvas.width;
                const height = particleCanvas.height;
                
                pCtx.fillStyle = '#1a1a1a';
                pCtx.fillRect(0, 0, width, height);
                
                const gradient = pCtx.createLinearGradient(0, 0, width, height);
                
                const hue1 = (time * 5) % 360; 
                const hue2 = (hue1 + 30) % 360;
                
                gradient.addColorStop(0, `hsla(${hue1}, 70%, 60%, 0.05)`);
                gradient.addColorStop(0.5, `hsla(${hue2}, 70%, 60%, 0.02)`);
                gradient.addColorStop(1, `hsla(${hue1}, 70%, 60%, 0.05)`);
                
                pCtx.fillStyle = gradient;
                
                for(let i = 0; i < 3; i++) {
                    const x = width/2 + Math.cos(time * 0.2 + i * Math.PI * 2/3) * width * 0.3;  
                    const y = height/2 + Math.sin(time * 0.15 + i * Math.PI * 2/3) * height * 0.3; 
                    
                    pCtx.beginPath();
                    pCtx.arc(x, y, Math.min(width, height) * 0.4, 0, Math.PI * 2);
                    pCtx.fill();
                }

                particles.forEach((particle, i) => {
                    particle.update();
                    
                    const opacity = particle.life / particle.maxLife;
                    pCtx.beginPath();
                    pCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    pCtx.fillStyle = `rgba(255, 200, 100, ${opacity * 0.5})`;
                    pCtx.fill();
                    
                    particles.slice(i + 1).forEach(other => {
                        const dx = particle.x - other.x;
                        const dy = particle.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 100) {
                            pCtx.beginPath();
                            pCtx.moveTo(particle.x, particle.y);
                            pCtx.lineTo(other.x, other.y);
                            pCtx.strokeStyle = `rgba(255, 200, 100, ${(1 - dist/100) * 0.2})`;
                            pCtx.stroke();
                        }
                    });
                });
            }
            
            requestAnimationFrame(animate);
        }

        animate();

        const GRID_SIZE = 4;
        const CELL_PADDING = 10;
        const ANIMATION_DURATION = 150;
        const ANIMATION_FPS = 60;
        const MERGE_SCALE = 1.1;
        const EASE_POWER = 2;

        let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        let animations = [];
        let score = 0;
        let gameOver = false;
        let bestScore = parseInt(localStorage.getItem('bestScore')) || 0;
        let won = false;
        let keepPlaying = false;
        let scoreAnimations = [];
        let currentMoveScoreIncrement = 0; 

        const stats = JSON.parse(localStorage.getItem('gameStats')) || {
            gamesPlayed: 0,
            highestTile: 0,
            totalScore: 0,
            averageScore: 0,
            bestTime: Infinity,
            lastPlayed: null,
            winCount: 0,
            moveCount: 0
        };

        let gameStartTime = Date.now();
        let moveCount = 0;

        const buttonTexts = {
            'GAMEPLAY': {
                title: 'HOW TO PLAY',
                text: [{
                    type: 'text',
                    content: 'Use arrow keys or swipe to combine matching tiles to reach the 2048 tile. If you reach the 2048 tile, you win! Keep playing to reach a high score or to discover new tiles!'
                }]
            },
            'SATS?': {
                title: 'DEFINITION',
                text: [{
                    type: 'text',
                    content: '/sæts/ abbr. pluralised form of Satoshi /səˈtoʊʃi/ - the smallest monetary unit in the Bitcoin digital payment system, equal to one hundred millionth of a bitcoin.'
                }]
            },
            'CREDITS': {
                title: 'CREDITS',
                text: [
                    { type: 'text', content: '2048 Sats was created by ' },
                    { type: 'link', content: 'BXL909', url: 'https://bxl909.github.io' },
                    { type: 'text', content: '. Based on ' },
                    { type: 'link', content: '2048', url: 'https://github.com/gabrielecirulli/2048' },
                    { type: 'text', content: ' by Gabriele Cirulli, which in turn was based on ' },
                    { type: 'link', content: '1024', url: 'https://itunes.apple.com/us/app/1024!/id823499224' },
                    { type: 'text', content: ' by Veewo Studio and conceptually similar to ' },
                    { type: 'link', content: 'Threes', url: 'http://asherv.com/threes/' },
                    { type: 'text', content: ' by Asher Vollmer.' }
                ]
            },
            'MORE': {
                title: 'OTHER PROJECTS',
                text: [
                    { type: 'text', content: 'For more of my Bitcoin apps, websites and games, visit ' },
                    { type: 'link', content: 'https://bxl909.github.io', url: 'https://bxl909.github.io' }
                ]
            },
            'TIPS': {
                title: 'TIPS',
                text: [
                    { type: 'text', content: 'All of my projects are free and ' },
                    { type: 'link', content: 'open source', url: 'https://github.com/BXL909' },
                    { type: 'text', content: '. If you like my work, maybe consider sending a small tip via Lightning⚡ to bxl909@walletofsatoshi.com or ' },
                    { type: 'link', content: 'here', url: 'https://strike.me/bxl909/' },
                    { type: 'text', content: ' or ' },
                    { type: 'link', content: 'here', url: 'https://zbd.gg/BTCdir' },
                    { type: 'text', content: ', or on-chain' },
                    { type: 'link', content: 'here', url: 'bitcoin:1BXL9o99CZVeD8jvd4pwQfDRfky1LvMqP1' },
                    { type: 'text', content: '.' }
                ]
            }
        };

        let activeButton = 'GAMEPLAY';  
        let activeButtonLinks = [];

        function getHighestTile() {
            let highest = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    highest = Math.max(highest, grid[y][x]);
                }
            }
            return highest;
        }

        function updateStats(gameWon) {
            stats.gamesPlayed++;
            stats.highestTile = Math.max(stats.highestTile, getHighestTile());
            stats.totalScore += score;
            stats.averageScore = Math.round(stats.totalScore / stats.gamesPlayed);
            stats.lastPlayed = new Date().toISOString();
            stats.moveCount += moveCount;
            if (gameWon) {
                stats.winCount++;
                const gameTime = Date.now() - gameStartTime;
                if (gameTime < stats.bestTime) {
                    stats.bestTime = gameTime;
                }
            }
            localStorage.setItem('gameStats', JSON.stringify(stats));
        }

        const priceChart = document.getElementById('priceChart');
        const chartCtx = priceChart.getContext('2d');
        
        async function setupPriceChart() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=30&interval=daily');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                const prices = data.prices.map(([timestamp, price]) => ({
                    x: new Date(timestamp),
                    y: price * 0.00002048
                }));

                const { gridSize, offsetX, offsetY } = getGameDimensions();
                const logo = document.getElementById('logo');
                const description = document.getElementById('description');
                
                logo.style.cssText = `
                    left: ${offsetX}px !important;
                    top: ${offsetY - logo.offsetHeight - 40}px !important;
                `;
                
                description.style.cssText = `
                    left: ${offsetX + logo.offsetWidth}px !important;
                    top: ${offsetY - logo.offsetHeight - 40}px !important;
                    width: ${gridSize - logo.offsetWidth}px !important;
                    height: ${logo.offsetHeight}px !important;
                `;

                priceChart.style.width = '100%';
                priceChart.style.height = '100%';
                
                const rect = priceChart.getBoundingClientRect();
                priceChart.width = rect.width;
                priceChart.height = rect.height;

                new Chart(priceChart.getContext('2d'), {
                    type: 'line',
                    data: {
                        datasets: [{
                            data: prices,
                            borderColor: '#FFA500',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.4,
                            backgroundColor: 'rgba(255, 165, 0, 0.1)'  
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => `$${context.parsed.y.toFixed(2)}`
                                },
                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                titleFont: {
                                    size: 16
                                },
                                bodyFont: {
                                    size: 16
                                }
                            },
                            title: {
                                display: true,
                                text: 'Value of 2048 sats (0.00002048 BTC) priced in $USD over 30 days',
                                align: 'start',
                                color: 'rgba(255, 255, 255, 0.8)',
                                font: {
                                    size: 24,
                                    family: 'Arial'
                                },
                                padding: {
                                    top: 10,
                                    bottom: 20
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                display: true,
                                time: {
                                    parser: 'yyyy-MM-dd',
                                    unit: 'day',
                                    displayFormats: {
                                        day: 'MMM d'
                                    },
                                    stepSize: 3  
                                },
                                grid: {
                                    display: false
                                },
                                ticks: {
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    font: {
                                        size: 16
                                    },
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                },
                                ticks: {
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: (value) => `$${value.toFixed(2)}`,
                                    font: {
                                        size: 16
                                    }
                                },
                                backgroundColor: 'rgba(26, 26, 26, 0.3)' 
                            }
                        },
                        backgroundColor: 'rgba(26, 26, 26, 0.3)'
                    }
                });
            } catch (error) {
                console.error('Error setting up price chart:', error);
                const description = document.getElementById('description');
                description.innerHTML = `<p style="color: rgba(255, 255, 255, 0.8); padding: 20px;">Unable to load price chart: ${error.message}</p>`;
            }
        }

        window.addEventListener('load', () => {
            const logo = document.getElementById('logo');
            if (logo.complete) {
                setupPriceChart();
            } else {
                logo.onload = setupPriceChart;
            }
        });

        function getGameDimensions() {
            const logoHeight = document.getElementById('logo').offsetHeight;
            const maxWidth = 1280;
            const scaleFactor = isMobileDevice() ? 0.95 : 0.8;
            const minDim = Math.min(
                Math.min(gameCanvas.width, maxWidth),
                gameCanvas.height - logoHeight
            ) * scaleFactor;
            const cellSize = minDim / GRID_SIZE;
            const gridSize = cellSize * GRID_SIZE;
            const offsetX = (gameCanvas.width - gridSize) / 2;
            const offsetY = logoHeight + (gameCanvas.height - logoHeight - gridSize) / 3;
            
            const performanceModeDiv = document.querySelector('div:has(#performanceMode)');
            performanceModeDiv.style.left = offsetX + 'px';
            performanceModeDiv.style.top = (offsetY + gridSize + 10) + 'px';
            
            const description = document.getElementById('description');
            const logo = document.getElementById('logo');
            description.style.width = (gridSize - logo.offsetWidth) + 'px';
            description.style.left = (offsetX + logo.offsetWidth) + 'px';
            description.style.top = (offsetY - logo.offsetHeight - 40) + 'px';  
            
            logo.style.left = offsetX + 'px';
            logo.style.top = (offsetY - logo.offsetHeight - 40) + 'px';  
            
            return { cellSize, gridSize, offsetX, offsetY };
        }

        function drawGame() {
            const { cellSize, gridSize, offsetX, offsetY } = getGameDimensions();
            const currentTime = getCurrentTime();
            
            const logo = document.getElementById('logo');
            logo.style.left = offsetX + 'px';
            logo.style.top = (offsetY - logo.offsetHeight - 40) + 'px';  
            
            const description = document.getElementById('description');
            description.style.left = (offsetX + logo.offsetWidth) + 'px';
            description.style.top = logo.style.top;
            description.style.width = (gridSize - logo.offsetWidth) + 'px';
            
            gCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            gCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            gCtx.font = '28px Arial';
            gCtx.textAlign = 'left';
            gCtx.textBaseline = 'bottom';
            gCtx.fillText('SCORE: ', offsetX, offsetY - 15);
            
            gCtx.fillStyle = 'rgba(255, 200, 150, 0.8)'; 
            const scoreWidth = gCtx.measureText('SCORE: ').width;
            gCtx.fillText(score, offsetX + scoreWidth, offsetY - 15);

            scoreAnimations = scoreAnimations.filter(anim => {
                const progress = (getCurrentTime() - anim.startTime) / anim.duration;
                if (progress >= 1) return false;

                const alpha = 1 - progress;
                
                gCtx.fillStyle = `rgba(50, 205, 50, ${alpha})`; 
                gCtx.fillText(`+${anim.value}`, 
                    offsetX + scoreWidth + gCtx.measureText(score).width + 10,
                    offsetY - 15);
                
                return true;
            });

            const resetButtonWidth = 60;
            const resetButtonHeight = 24;
            const resetButtonPadding = 10;

            gCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            gCtx.textAlign = 'right';
            const bestScoreX = offsetX + gridSize - resetButtonWidth - resetButtonPadding;
            gCtx.fillText('BEST SCORE: ', bestScoreX - gCtx.measureText(bestScore).width, offsetY - 15);

            gCtx.fillStyle = 'rgba(255, 200, 150, 0.8)';  
            gCtx.fillText(bestScore, bestScoreX, offsetY - 15);

            const resetButtonX = bestScoreX + resetButtonPadding;
            const resetButtonY = offsetY - 44; 

            gCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            gCtx.fillRect(resetButtonX, resetButtonY, resetButtonWidth, resetButtonHeight);
            gCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            gCtx.strokeRect(resetButtonX, resetButtonY, resetButtonWidth, resetButtonHeight);

            gCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            gCtx.font = '15px Arial';
            gCtx.textAlign = 'center';
            gCtx.textBaseline = 'middle';
            gCtx.fillText('RESET', resetButtonX + resetButtonWidth/2, resetButtonY + resetButtonHeight/2 + 1);

            gCtx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            gCtx.fillRect(offsetX, offsetY, gridSize, gridSize);
            gCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            gCtx.lineWidth = 2;
            gCtx.strokeRect(offsetX, offsetY, gridSize, gridSize);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cellX = offsetX + x * cellSize;
                    const cellY = offsetY + y * cellSize;
                    gCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    gCtx.strokeRect(cellX, cellY, cellSize, cellSize);
                }
            }
            
            const animatingPositions = new Set();
            const mergeDestinations = new Set();
            
            animations.forEach(anim => {
                const startX = Math.round((anim.startX - offsetX) / cellSize);
                const startY = Math.round((anim.startY - offsetY) / cellSize);
                animatingPositions.add(`${startX},${startY}`);
                
                const endX = Math.round((anim.endX - offsetX) / cellSize);
                const endY = Math.round((anim.endY - offsetY) / cellSize);
                if (!anim.completed) {
                    mergeDestinations.add(`${endX},${endY}`);
                }
            });
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const pos = `${x},${y}`;
                    if (animatingPositions.has(pos)) continue;
                    
                    const hasNearingAnimation = animations.some(anim => 
                        anim.nearingCompletion && 
                        Math.round((anim.endX - offsetX) / cellSize) === x && 
                        Math.round((anim.endY - offsetY) / cellSize) === y
                    );
                    
                    if (mergeDestinations.has(pos) && !hasNearingAnimation) continue;
                    
                    const value = grid[y][x];
                    if (value === 0) continue;
                    
                    drawCell(offsetX + x * cellSize, offsetY + y * cellSize, cellSize, value);
                }
            }
            
            animations = animations.filter(anim => {
                const progress = (getCurrentTime() - anim.startTime) / ANIMATION_DURATION;
                
                if (progress >= 1.05) {
                    if (anim.type === 'zoom' && !anim.completed) {
                        return true;
                    }
                    if (anim.type === 'slide' && !anim.completed) {
                        anim.completed = true;
                        return false;
                    }
                    return false;
                }

                if (anim.type === 'slide') {
                    const eased = easeOut(Math.min(progress, 1));
                    const x = anim.startX + (anim.endX - anim.startX) * eased;
                    const y = anim.startY + (anim.endY - anim.startY) * eased;
                    
                    if (progress > 0.95) {
                        anim.nearingCompletion = true;
                    }
                    
                    if (anim.willMerge && progress > 0.8) {
                        const mergeScale = 1 + (MERGE_SCALE - 1) * ((progress - 0.8) / 0.2);
                        gCtx.save();
                        gCtx.translate(x + cellSize/2, y + cellSize/2);
                        gCtx.scale(mergeScale, mergeScale);
                        drawCell(-cellSize/2, -cellSize/2, cellSize, anim.value);
                        gCtx.restore();
                    } else {
                        drawCell(x, y, cellSize, anim.value);
                    }
                }
                
                return true;
            });
            
            if (won && !keepPlaying) {
                showWinScreen();
            } else if (gameOver) {
                showGameOver();
            }

            const buttonRowY = offsetY + gridSize + 20; 
            const squareButtonSize = 45;
            const totalWidth = gridSize;
            const regularButtonWidth = (totalWidth - squareButtonSize) / 5; 
            
            const buttonFontSize = isMobileDevice() ? '24px' : '18px';
            gCtx.font = `${buttonFontSize} Arial`;
            gCtx.textAlign = 'center';
            gCtx.textBaseline = 'middle';
            
            const buttonLabels = ['GAMEPLAY', 'SATS?', 'CREDITS', 'MORE', 'TIPS'];
            buttonLabels.forEach((label, i) => {
                const buttonX = offsetX + (regularButtonWidth * i);
                const isActive = label === activeButton;
                
                gCtx.fillStyle = isActive ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.1)';
                gCtx.fillRect(buttonX, buttonRowY, regularButtonWidth - 2, squareButtonSize);
                
                gCtx.fillStyle = isActive ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 165, 0, 0.8)';
                gCtx.fillText(label, buttonX + regularButtonWidth / 2, buttonRowY + squareButtonSize / 2);
            });
            
            const squareButtonX = offsetX + gridSize - squareButtonSize;
            gCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            gCtx.fillRect(squareButtonX, buttonRowY, squareButtonSize, squareButtonSize);

            const padding = 0;
            gCtx.drawImage(
                miniLogo,
                squareButtonX + padding,
                buttonRowY + padding,
                squareButtonSize - (padding * 2),
                squareButtonSize - (padding * 2)
            );

            if (activeButton) {
                const textY = buttonRowY + squareButtonSize + 20;
                const textWidth = gridSize;
                drawButtonContent(activeButton, offsetX, textY, textWidth);
            }
        }

        function drawCell(x, y, size, value) {
            const padding = CELL_PADDING;
            const innerSize = size - padding * 2;
            const radius = 15;
            
            gCtx.save();
            gCtx.translate(x + padding, y + padding);
            
            const hue = (Math.log2(value) * 30) % 360;
            
            gCtx.beginPath();
            gCtx.moveTo(0 + radius, 0);
            gCtx.lineTo(innerSize - radius, 0);
            gCtx.quadraticCurveTo(innerSize, 0, innerSize, 0 + radius);
            gCtx.lineTo(innerSize, innerSize - radius);
            gCtx.quadraticCurveTo(innerSize, innerSize, innerSize - radius, innerSize);
            gCtx.lineTo(0 + radius, innerSize);
            gCtx.quadraticCurveTo(0, innerSize, 0, innerSize - radius);
            gCtx.lineTo(0, 0 + radius);
            gCtx.quadraticCurveTo(0, 0, 0 + radius, 0);
            gCtx.closePath();
            
            gCtx.fillStyle = `hsla(${hue}, 70%, 60%, 0.2)`;
            gCtx.fill();
            gCtx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.3)`;
            gCtx.lineWidth = 2;
            gCtx.stroke();
            
            gCtx.beginPath();
            const corners = Math.log2(value);
            const patternRadius = innerSize * 0.43;
            for (let i = 0; i < corners; i++) {
                const angle = (i / corners) * Math.PI * 2;
                const px = innerSize/2 + Math.cos(angle) * patternRadius;
                const py = innerSize/2 + Math.sin(angle) * patternRadius;
                i === 0 ? gCtx.moveTo(px, py) : gCtx.lineTo(px, py);
            }
            gCtx.closePath();
            gCtx.stroke();
            
            gCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            gCtx.font = `bold ${innerSize / 3}px Arial`;
            gCtx.textAlign = 'center';
            gCtx.textBaseline = 'middle';
            gCtx.fillText(value.toString(), innerSize / 2, innerSize / 2);
            
            gCtx.restore();
        }

        function addNewTile() {
            const emptyCells = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === 0) emptyCells.push({x, y});
                }
            }
            
            if (emptyCells.length > 0) {
                const {x, y} = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const value = Math.random() < 0.9 ? 2 : 4;
                
                const { cellSize, offsetX, offsetY } = getGameDimensions();
                const newAnimation = {
                    type: 'zoom',
                    x: offsetX + x * cellSize,
                    y: offsetY + y * cellSize,
                    value: value,
                    startTime: getCurrentTime(),
                    gridX: x,
                    gridY: y,
                    completed: false 
                };
                animations.push(newAnimation);
                
                grid[y][x] = value;
                
                newAnimation.completed = true;
            }
        }

        let lastMoveDirection = null;

        function getCurrentTime() {
            return performance.now();
        }

        function canMoveInDirection(direction) {
            let testGrid = grid.map(row => [...row]);
            let moved = false;
            
            if (direction === 'left' || direction === 'right') {
                testGrid = testGrid.map(row => direction === 'right' ? row.reverse() : row);
            } else {
                testGrid = transpose(testGrid);
                testGrid = testGrid.map(row => direction === 'down' ? row.reverse() : row);
            }
            
            for (let row of testGrid) {
                const originalRow = [...row];
                
                let cells = row.filter(cell => cell !== 0);
                
                for (let i = 0; i < cells.length - 1; i++) {
                    if (cells[i] !== 0 && cells[i] === cells[i + 1]) {
                        moved = true;
                        break;
                    }
                }
                
                while (cells.length < GRID_SIZE) {
                    cells.push(0);
                }
                
                for (let i = 0; i < GRID_SIZE; i++) {
                    if (cells[i] !== originalRow[i]) {
                        moved = true;
                        break;
                    }
                }
                
                if (moved) break;
            }
            
            return moved;
        }

        function move(direction) {
            if (gameOver || animations.length > 0 || (won && !keepPlaying)) return;
            
            currentMoveScoreIncrement = 0;  
            const oldScore = score; 
            
            if (!canMoveInDirection(direction)) {
                if (!canMoveInDirection('up') && !canMoveInDirection('down') && 
                    !canMoveInDirection('left') && !canMoveInDirection('right')) {
                    gameOver = true;
                    if (score > bestScore) {
                        bestScore = score;
                        localStorage.setItem('bestScore', bestScore);
                    }
                }
                return;
            }
            
            lastMoveDirection = direction;
            const oldGrid = grid.map(row => [...row]);
            let moved = false;
            
            let rows = [...grid].map(row => [...row]);
            if (direction === 'left' || direction === 'right') {
                rows = rows.map(row => direction === 'right' ? row.reverse() : row);
            } else {
                rows = transpose(rows);
                rows = rows.map(row => direction === 'down' ? row.reverse() : row);
            }
            
            rows = rows.map(row => {
                const originalRow = [...row];
                let newRow = Array(GRID_SIZE).fill(0);
                let writeIndex = 0;
                
                let numbers = row.filter(cell => cell !== 0);
                
                for (let i = 0; i < numbers.length; i++) {
                    if (i + 1 < numbers.length && numbers[i] === numbers[i + 1]) {
                        newRow[writeIndex] = numbers[i] * 2;
                        const increment = numbers[i] * 2;
                        score += increment;
                        currentMoveScoreIncrement += increment;
                        i++;
                    } else {
                        newRow[writeIndex] = numbers[i];
                    }
                    writeIndex++;
                }
                
                if (newRow.join(',') !== originalRow.join(',')) {
                    moved = true;
                }
                
                if (currentMoveScoreIncrement > 0) {
                    scoreAnimations = [];
                    scoreAnimations.push({
                        value: currentMoveScoreIncrement,
                        startTime: getCurrentTime(),
                        duration: 1000  
                    });
                    currentMoveScoreIncrement = 0;  
                }
                
                return newRow;
            });
            
            if (direction === 'left' || direction === 'right') {
                if (direction === 'right') {
                    rows = rows.map(row => row.reverse());
                }
            } else {
                if (direction === 'down') {
                    rows = rows.map(row => row.reverse());
                }
                rows = transpose(rows);
            }
            
            if (moved) {
                moveCount++;
                grid = rows;
                createMoveAnimations(oldGrid, rows, getCurrentTime());
                
                const checkAnimations = () => {
                    if (animations.length === 0) {
                        addNewTile();
                        
                        setTimeout(() => {
                            if (!won && hasWon()) { 
                                won = true;
                                updateStats(true); 
                                showWinScreen();
                            } else if (isGameOver()) {
                                gameOver = true;
                                updateStats(false);
                                if (score > bestScore) {
                                    bestScore = score;
                                    localStorage.setItem('bestScore', bestScore);
                                }
                            }
                        }, ANIMATION_DURATION);
                    } else {
                        requestAnimationFrame(checkAnimations);
                    }
                };
                
                requestAnimationFrame(checkAnimations);
            }
            
            if (score > oldScore) {  
                scoreAnimations = []; 
                scoreAnimations.push({
                    value: score - oldScore,
                    startTime: getCurrentTime(),
                    duration: 1000
                });
            }
        }

        function transpose(grid) {
            return grid[0].map((_, i) => grid.map(row => row[i]));
        }

        function createPreMergeGrid(oldGrid, newGrid) {
            let sequence = [];
            let currentGrid = oldGrid.map(row => [...row]);
            
            const range = [...Array(GRID_SIZE).keys()];
            const yRange = lastMoveDirection === 'down' ? [...range].reverse() : range;
            const xRange = lastMoveDirection === 'right' ? [...range].reverse() : range;
            
            for (const y of yRange) {
                for (const x of xRange) {
                    if (currentGrid[y][x] === 0) continue;
                    
                    let value = currentGrid[y][x];
                    let currentY = y;
                    let currentX = x;
                    
                    while (true) {
                        let nextY = currentY;
                        let nextX = currentX;
                        
                        if (lastMoveDirection === 'up') nextY--;
                        else if (lastMoveDirection === 'down') nextY++;
                        else if (lastMoveDirection === 'left') nextX--;
                        else if (lastMoveDirection === 'right') nextX++;
                        
                        if (nextX < 0 || nextX >= GRID_SIZE || nextY < 0 || nextY >= GRID_SIZE) break;
                        
                        if (currentGrid[nextY][nextX] !== 0) break;
                        
                        let newGrid = currentGrid.map(row => [...row]);
                        newGrid[currentY][currentX] = 0;
                        newGrid[nextY][nextX] = value;
                        sequence.push(newGrid);
                        
                        currentGrid = newGrid;
                        currentY = nextY;
                        currentX = nextX;
                    }
                }
            }
            
            return sequence.length > 0 ? sequence[sequence.length - 1] : currentGrid;
        }

        function createMoveAnimations(oldGrid, newGrid, startTime) {
            const { cellSize, offsetX, offsetY } = getGameDimensions();
            animations = [];
            
            const hasValidPath = (x, y, value) => {
                let moved = false;
                
                if (lastMoveDirection === 'right') {
                    for (let newX = x + 1; newX < GRID_SIZE; newX++) {
                        if (newGrid[y][newX] === value || newGrid[y][newX] === value * 2) {
                            moved = true;
                            break;
                        }
                    }
                } else if (lastMoveDirection === 'left') {
                    for (let newX = x - 1; newX >= 0; newX--) {
                        if (newGrid[y][newX] === value || newGrid[y][newX] === value * 2) {
                            moved = true;
                            break;
                        }
                    }
                } else if (lastMoveDirection === 'down') {
                    for (let newY = y + 1; newY < GRID_SIZE; newY++) {
                        if (newGrid[newY][x] === value || newGrid[newY][x] === value * 2) {
                            moved = true;
                            break;
                        }
                    }
                } else if (lastMoveDirection === 'up') {
                    for (let newY = y - 1; newY >= 0; newY--) {
                        if (newGrid[newY][x] === value || newGrid[newY][x] === value * 2) {
                            moved = true;
                            break;
                        }
                    }
                }
                
                return moved;
            };
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const value = oldGrid[y][x];
                    if (value === 0) continue;
                    
                    if (!hasValidPath(x, y, value)) continue;
                    
                    let finalX = x;
                    let finalY = y;
                    let willMerge = false;
                    
                    if (lastMoveDirection === 'right' || lastMoveDirection === 'left') {
                        const row = oldGrid[y];
                        const sameTiles = row.filter(cell => cell === value).length;
                        
                        if (sameTiles === 3) {
                            const tilePositions = row.map((cell, i) => cell === value ? i : -1).filter(i => i !== -1);
                            const tileIndex = tilePositions.indexOf(x);
                            
                            if (lastMoveDirection === 'right') {
                                if (tileIndex === 0) { 
                                    finalX = GRID_SIZE - 2;
                                } else { 
                                    finalX = GRID_SIZE - 1;
                                    willMerge = tileIndex === 2;
                                }
                            } else { 
                                if (tileIndex === 2) { 
                                    finalX = 1;
                                } else { 
                                    finalX = 0;
                                    willMerge = tileIndex === 0;
                                }
                            }
                        } else {
                            const rowTiles = [];
                            if (lastMoveDirection === 'right') {
                                for (let i = 0; i < GRID_SIZE; i++) {
                                    if (oldGrid[y][i] !== 0) {
                                        rowTiles.push({ x: i, value: oldGrid[y][i] });
                                    }
                                }
                            }
                            else {
                                for (let i = GRID_SIZE - 1; i >= 0; i--) {
                                    if (oldGrid[y][i] !== 0) {
                                        rowTiles.push({ x: i, value: oldGrid[y][i] });
                                    }
                                }
                            }
                            
                            const tileIndex = rowTiles.findIndex(t => t.x === x);
                            if (tileIndex !== -1) {
                                const nextTile = rowTiles[tileIndex + 1];
                                const willMergeWithNext = nextTile && nextTile.value === value;
                                
                                let mergesBeforeThis = 0;
                                for (let i = tileIndex + 1; i < rowTiles.length - 1; i++) {
                                    if (rowTiles[i].value === rowTiles[i + 1].value) {
                                        mergesBeforeThis++;
                                        i++;
                                    }
                                }
                                
                                if (lastMoveDirection === 'right') {
                                    if (willMergeWithNext) {
                                        finalX = GRID_SIZE - (rowTiles.length - tileIndex - 1) + mergesBeforeThis;
                                        willMerge = true;
                                    } else {
                                        finalX = GRID_SIZE - (rowTiles.length - tileIndex) + mergesBeforeThis;
                                    }
                                } else {
                                    if (willMergeWithNext) {
                                        finalX = rowTiles.length - tileIndex - 2 - mergesBeforeThis;
                                        willMerge = true;
                                    } else {
                                        finalX = rowTiles.length - tileIndex - 1 - mergesBeforeThis;
                                    }
                                }
                            }
                        }
                    } else {
                        const col = Array(GRID_SIZE).fill().map((_, i) => oldGrid[i][x]);
                        const sameTiles = col.filter(cell => cell === value).length;
                        
                        if (sameTiles === 3) {
                            const tilePositions = col.map((cell, i) => cell === value ? i : -1).filter(i => i !== -1);
                            const tileIndex = tilePositions.indexOf(y);
                            
                            if (lastMoveDirection === 'down') {
                                if (tileIndex === 0) {
                                    finalY = GRID_SIZE - 2;
                                } else {
                                    finalY = GRID_SIZE - 1;
                                    willMerge = tileIndex === 2;
                                }
                            } else { 
                                if (tileIndex === 2) { 
                                    finalY = 1;
                                } else { 
                                    finalY = 0;
                                    willMerge = tileIndex === 0;
                                }
                            }
                        } else {
                            const colTiles = [];
                            if (lastMoveDirection === 'down') {
                                for (let i = 0; i < GRID_SIZE; i++) {
                                    if (oldGrid[i][x] !== 0) {
                                        colTiles.push({ y: i, value: oldGrid[i][x] });
                                    }
                                }
                            }
                            else {
                                for (let i = GRID_SIZE - 1; i >= 0; i--) {
                                    if (oldGrid[i][x] !== 0) {
                                        colTiles.push({ y: i, value: oldGrid[i][x] });
                                    }
                                }
                            }
                            
                            const tileIndex = colTiles.findIndex(t => t.y === y);
                            if (tileIndex !== -1) {
                                const nextTile = colTiles[tileIndex + 1];
                                const willMergeWithNext = nextTile && nextTile.value === value;
                                
                                let mergesBeforeThis = 0;
                                for (let i = tileIndex + 1; i < colTiles.length - 1; i++) {
                                    if (colTiles[i].value === colTiles[i + 1].value) {
                                        mergesBeforeThis++;
                                        i++;
                                    }
                                }
                                
                                if (lastMoveDirection === 'down') {
                                    if (willMergeWithNext) {
                                        finalY = GRID_SIZE - (colTiles.length - tileIndex - 1) + mergesBeforeThis;
                                        willMerge = true;
                                    } else {
                                        finalY = GRID_SIZE - (colTiles.length - tileIndex) + mergesBeforeThis;
                                    }
                                } else {
                                    if (willMergeWithNext) {
                                        finalY = colTiles.length - tileIndex - 2 - mergesBeforeThis;
                                        willMerge = true;
                                    } else {
                                        finalY = colTiles.length - tileIndex - 1 - mergesBeforeThis;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (finalX !== x || finalY !== y) {
                        animations.push({
                            type: 'slide',
                            startX: offsetX + x * cellSize,
                            startY: offsetY + y * cellSize,
                            endX: offsetX + finalX * cellSize,
                            endY: offsetY + finalY * cellSize,
                            value: value,
                            startTime: startTime,
                            willMerge: willMerge
                        });
                    }
                }
            }
        }

        function canReachPosition(startX, startY, endX, endY) {
            if (lastMoveDirection === 'left') {
                return startY === endY && endX < startX;
            } else if (lastMoveDirection === 'right') {
                return startY === endY && endX > startX;
            } else if (lastMoveDirection === 'up') {
                return startX === endX && endY < startY;
            } else if (lastMoveDirection === 'down') {
                return startX === endX && endY > startY;
            }
            return false;
        }

        window.addEventListener('keydown', e => {
            switch(e.key) {
                case 'ArrowLeft': move('left'); break;
                case 'ArrowRight': move('right'); break;
                case 'ArrowUp': move('up'); break;
                case 'ArrowDown': move('down'); break;
            }
        });

        let touchStartX, touchStartY, touchStartTime;

        gameCanvas.addEventListener('touchstart', e => {
            const { gridSize, offsetX, offsetY } = getGameDimensions();
            const touch = e.touches[0];
            
            touchStartTime = Date.now();
            
            if (touch.clientX >= offsetX && touch.clientX <= offsetX + gridSize &&
                touch.clientY >= offsetY && touch.clientY <= offsetY + gridSize) {
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                e.preventDefault();
            }
        }, { passive: false });

        gameCanvas.addEventListener('touchend', e => {
            const { gridSize, offsetX, offsetY } = getGameDimensions();
            const touch = e.changedTouches[0];
            
            if (gameOver) {
                const buttonWidth = 160;
                const buttonHeight = 40;
                const buttonX = offsetX + gridSize / 2 - buttonWidth / 2;
                const buttonY = offsetY + gridSize / 2 + 120;
                
                if (touch.clientX >= buttonX && touch.clientX <= buttonX + buttonWidth &&
                    touch.clientY >= buttonY && touch.clientY <= buttonY + buttonHeight) {
                    restartGame();
                    e.preventDefault();
                    return;
                }
            }
            
            if (won && !keepPlaying) {
                const buttonWidth = 160;
                const buttonHeight = 40;
                const buttonSpacing = 20;
                const buttonY = offsetY + gridSize / 2 + 120;
                
                const keepPlayingX = offsetX + gridSize / 2 - buttonWidth - buttonSpacing/2;
                if (touch.clientX >= keepPlayingX && touch.clientX <= keepPlayingX + buttonWidth &&
                    touch.clientY >= buttonY && touch.clientY <= buttonY + buttonHeight) {
                    keepPlaying = true;
                    e.preventDefault();
                    return;
                }
                
                const newGameX = offsetX + gridSize / 2 + buttonSpacing/2;
                if (touch.clientX >= newGameX && touch.clientX <= newGameX + buttonWidth &&
                    touch.clientY >= buttonY && touch.clientY <= buttonY + buttonHeight) {
                    won = false;
                    keepPlaying = false;
                    restartGame();
                    e.preventDefault();
                    return;
                }
            }
            
            if (touchStartX !== undefined && touchStartY !== undefined) {
                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - touchStartTime;
                
                const dx = touch.clientX - touchStartX;
                const dy = touch.clientY - touchStartY;
                
                const minSwipeDistance = 20;
                const maxSwipeTime = 300;
                
                if (touchDuration <= maxSwipeTime && 
                    (Math.abs(dx) > minSwipeDistance || Math.abs(dy) > minSwipeDistance)) {
                    
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    if (angle > -45 && angle <= 45) {
                        move('right');
                    } else if (angle > 45 && angle <= 135) {
                        move('down');
                    } else if (angle > 135 || angle <= -135) {
                        move('left');
                    } else {
                        move('up');
                    }
                    
                    e.preventDefault();
                }
            }
            
            touchStartX = undefined;
            touchStartY = undefined;
            touchStartTime = undefined;
        }, { passive: false });

        gameCanvas.addEventListener('touchmove', e => {
            const { gridSize, offsetX, offsetY } = getGameDimensions();
            const touch = e.touches[0];
            
            if (touchStartX !== undefined && touchStartY !== undefined) {
                e.preventDefault();
            }
        }, { passive: false });

        function updateGame() {
            requestAnimationFrame(updateGame);
            drawGame();
        }

        function initializeGame() {
            addNewTile();
            addNewTile();
            updateGame();
        }

        initializeGame();

        function isGameOver() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === 0) return false;
                }
            }
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const value = grid[y][x];
                    
                    if (x < GRID_SIZE - 1 && grid[y][x + 1] === value) return false;
                    if (y < GRID_SIZE - 1 && grid[y + 1][x] === value) return false;
                }
            }
            
            return true;
        }

        function restartGame() {
            if (grid.some(row => row.some(cell => cell > 0))) {
                updateStats(false); 
            }
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            animations = [];
            score = 0;
            gameOver = false;
            won = false;
            keepPlaying = false;
            moveCount = 0;
            gameStartTime = Date.now();
            addNewTile();
            addNewTile();
        }

        gameCanvas.addEventListener('click', (e) => {
            if (!gameOver) return;
            
            const { gridSize, offsetX, offsetY } = getGameDimensions();
            const buttonWidth = 200;
            const buttonHeight = 50;
            const buttonX = offsetX + gridSize / 2 - buttonWidth / 2;
            const buttonY = offsetY + gridSize / 2 + 120;
            
            if (e.clientX >= buttonX && e.clientX <= buttonX + buttonWidth &&
                e.clientY >= buttonY && e.clientY <= buttonY + buttonHeight) {
                restartGame();
            }
        });

        function easeOut(x) {
            return 1 - Math.pow(1 - x, 3);
        }

        function createMergeAnimations(premergeGrid, newGrid) {
            const { cellSize, offsetX, offsetY } = getGameDimensions();
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (newGrid[y][x] !== premergeGrid[y][x] && newGrid[y][x] > 0) {
                        animations.push({
                            type: 'merge',
                            x: offsetX + x * cellSize,
                            y: offsetY + y * cellSize,
                            value: newGrid[y][x],
                            startTime: Date.now()
                        });
                    }
                }
            }
        }

        function canMakeMove(oldGrid, newGrid) {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (oldGrid[y][x] !== newGrid[y][x]) {
                        if (!(oldGrid[y][x] === 0 && newGrid[y][x] === 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function showWinScreen() {
            const { gridSize, offsetX, offsetY } = getGameDimensions();
            
            gCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            gCtx.fillRect(offsetX, offsetY, gridSize, gridSize);
            
            gCtx.fillStyle = 'white';
            gCtx.font = 'bold 40px Arial';
            gCtx.textAlign = 'center';
            gCtx.textBaseline = 'middle';
            gCtx.fillText('2048 SATS ACHIEVED!', 
                offsetX + gridSize / 2, 
                offsetY + gridSize / 2 - 100);
            
            const currentGamesPlayed = stats.gamesPlayed + 1;
            const winRate = currentGamesPlayed > 0 
                ? Math.round((stats.winCount / currentGamesPlayed) * 100) 
                : 0;
            
            gCtx.font = '20px Arial';
            const statsText = [
                `Final Score: ${score}`,
                `Highest Tile: ${getHighestTile()}`,
                `Moves: ${moveCount}`,
                `Games Played: ${currentGamesPlayed}`,
                `Best Score: ${bestScore}`,
                `Win Rate: ${winRate}%`
            ];
            
            statsText.forEach((text, i) => {
                gCtx.fillText(text,
                    offsetX + gridSize / 2,
                    offsetY + gridSize / 2 - 60 + i * 30);
            });
            
            const buttonWidth = 160;
            const buttonHeight = 40;
            const buttonSpacing = 20;
            
            const keepPlayingX = offsetX + gridSize / 2 - buttonWidth - buttonSpacing/2;
            const buttonY = offsetY + gridSize / 2 + 120; 
            
            gCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            gCtx.fillRect(keepPlayingX, buttonY, buttonWidth, buttonHeight);
            gCtx.strokeStyle = 'white';
            gCtx.strokeRect(keepPlayingX, buttonY, buttonWidth, buttonHeight);
            
            gCtx.fillStyle = 'white';
            gCtx.font = '20px Arial';
            gCtx.fillText('KEEP GOING', 
                keepPlayingX + buttonWidth/2, 
                buttonY + buttonHeight/2);
            
            const newGameX = offsetX + gridSize / 2 + buttonSpacing/2;
            
            gCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            gCtx.fillRect(newGameX, buttonY, buttonWidth, buttonHeight);
            gCtx.strokeStyle = 'white';
            gCtx.strokeRect(newGameX, buttonY, buttonWidth, buttonHeight);
            
            gCtx.fillStyle = 'white';
            gCtx.font = '20px Arial';
            gCtx.fillText('NEW GAME', 
                newGameX + buttonWidth/2, 
                buttonY + buttonHeight/2);
        }

        gameCanvas.addEventListener('click', (e) => {
            if (won && !keepPlaying) {
                const { gridSize, offsetX, offsetY } = getGameDimensions();
                const buttonWidth = 160;
                const buttonHeight = 40;
                const buttonSpacing = 20;
                const buttonY = offsetY + gridSize / 2 + 120;
                
                const keepPlayingX = offsetX + gridSize / 2 - buttonWidth - buttonSpacing/2;
                if (e.clientX >= keepPlayingX && e.clientX <= keepPlayingX + buttonWidth &&
                    e.clientY >= buttonY && e.clientY <= buttonY + buttonHeight) {
                    keepPlaying = true;
                }
                
                const newGameX = offsetX + gridSize / 2 + buttonSpacing/2;
                if (e.clientX >= newGameX && e.clientX <= newGameX + buttonWidth &&
                    e.clientY >= buttonY && e.clientY <= buttonY + buttonHeight) {
                    won = false;
                    keepPlaying = false;
                    restartGame();
                }
            }
        });

        function isPositionMergeResult(x, y, oldGrid, newGrid) {
            const value = newGrid[y][x];
            if (value === 0) return false;
            
            let oldCount = 0;
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (oldGrid[i][j] === value/2) oldCount++;
                }
            }
            
            let newCount = 0;
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (newGrid[i][j] === value) newCount++;
                }
            }
            
            return oldCount > newCount;
        }

        function hasWon() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === 2048) { 
                        return true;
                    }
                }
            }
            return false;
        }

        gameCanvas.addEventListener('click', (e) => {
            const { gridSize, offsetX, offsetY } = getGameDimensions();
            const resetButtonWidth = 60;
            const resetButtonHeight = 24;
            const resetButtonPadding = 10;
            const bestScoreX = offsetX + gridSize - resetButtonWidth - resetButtonPadding;
            const resetButtonX = bestScoreX + resetButtonPadding;
            const resetButtonY = offsetY - 38;

            if (e.clientX >= resetButtonX && e.clientX <= resetButtonX + resetButtonWidth &&
                e.clientY >= resetButtonY && e.clientY <= resetButtonY + resetButtonHeight) {
                bestScore = 0;
                localStorage.setItem('bestScore', '0');

                stats.gamesPlayed = 0;
                stats.highestTile = 0;
                stats.totalScore = 0;
                stats.averageScore = 0;
                stats.bestTime = Infinity;
                stats.lastPlayed = null;
                stats.winCount = 0;
                stats.moveCount = 0;
                localStorage.setItem('gameStats', JSON.stringify(stats));
            }
        });

        function showGameOver() {
            const { gridSize, offsetX, offsetY } = getGameDimensions();
            
            gCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            gCtx.fillRect(offsetX, offsetY, gridSize, gridSize);
            
            gCtx.fillStyle = 'white';
            gCtx.font = 'bold 30px Arial';
            gCtx.textAlign = 'center';
            gCtx.textBaseline = 'middle';
            gCtx.fillText('GAME OVER', 
                offsetX + gridSize / 2, 
                offsetY + gridSize / 2 - 100);
            
            const currentGamesPlayed = stats.gamesPlayed + 1;  
            const winRate = currentGamesPlayed > 0 
                ? Math.round((stats.winCount / currentGamesPlayed) * 100) 
                : 0;
            
            gCtx.font = '16px Arial';
            const statsText = [
                `Final Score: ${score}`,
                `Highest Tile: ${getHighestTile()}`,
                `Moves: ${moveCount}`,
                `Games Played: ${currentGamesPlayed}`,
                `Best Score: ${bestScore}`,
                `Win Rate: ${winRate}%`
            ];
            
            statsText.forEach((text, i) => {
                gCtx.fillText(text,
                    offsetX + gridSize / 2,
                    offsetY + gridSize / 2 - 60 + i * 30);
            });
            
            const buttonWidth = 160;
            const buttonHeight = 40;
            const buttonX = offsetX + gridSize / 2 - buttonWidth / 2;
            const buttonY = offsetY + gridSize / 2 + 120;
            
            gCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            gCtx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
            gCtx.strokeStyle = 'white';
            gCtx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
            
            gCtx.fillStyle = 'white';
            gCtx.fillText('NEW GAME',
                offsetX + gridSize / 2,
                buttonY + buttonHeight / 2);
        }

        gameCanvas.addEventListener('click', (e) => {
            const { gridSize, offsetX, offsetY } = getGameDimensions();
            const buttonRowY = offsetY + gridSize + 20;
            const squareButtonSize = 45;
            const totalWidth = gridSize;
            const regularButtonWidth = (totalWidth - squareButtonSize) / 5;
            
            if (e.clientY >= buttonRowY && e.clientY <= buttonRowY + squareButtonSize) {
                const buttonLabels = ['GAMEPLAY', 'SATS?', 'CREDITS', 'MORE', 'TIPS'];
                
                for (let i = 0; i < 5; i++) { 
                    const buttonX = offsetX + (regularButtonWidth * i);
                    if (e.clientX >= buttonX && e.clientX <= buttonX + regularButtonWidth - 2) {
                        activeButton = buttonLabels[i];
                        return;
                    }
                }
                
                const squareButtonX = offsetX + gridSize - squareButtonSize;
                if (e.clientX >= squareButtonX && e.clientX <= squareButtonX + squareButtonSize) {
                    window.open('https://bxl909.github.io', '_blank');
                    return;
                }
            }
            else if (activeButton && activeButtonLinks.length > 0) {
                const textY = buttonRowY + squareButtonSize + 20;
                const boxHeight = isMobileDevice() ? 120 : 80;
                
                if (e.clientY >= textY && e.clientY <= textY + boxHeight) {
                    for (const link of activeButtonLinks) {
                        if (e.clientX >= link.x && 
                            e.clientX <= link.x + link.width &&
                            e.clientY >= link.y && 
                            e.clientY <= link.y + link.height) {
                            window.open(link.url, '_blank');
                            return;
                        }
                    }
                }
            }
        });

        function drawButtonContent(activeButton, offsetX, textY, textWidth) {
            if (!activeButton || !buttonTexts[activeButton]) return;
            
            const content = buttonTexts[activeButton];
            const padding = 20;
            
            gCtx.fillStyle = 'rgba(255, 200, 150, 0.8)';
            gCtx.font = `bold ${isMobileDevice() ? '24px' : '24px'} Arial`;
            gCtx.textAlign = 'left';
            gCtx.textBaseline = 'top';
            gCtx.fillText(content.title + ':', offsetX + padding, textY + padding);
            
            activeButtonLinks = [];
            
            gCtx.font = `${isMobileDevice() ? '32px' : '22px'} Arial`;
            let x = offsetX + padding;
            let y = textY + padding + (isMobileDevice() ? 30 : 25);
            const maxWidth = textWidth - (padding * 2);
            let currentLine = '';
            let words = [];
            
            content.text.forEach(segment => {
                words = words.concat(segment.content.split(' ').map(word => ({
                    word,
                    type: segment.type,
                    url: segment.url
                })));
            });
            
            let currentLineSegments = [];
            
            for (let i = 0; i < words.length; i++) {
                const wordObj = words[i];
                const testLine = currentLine + (currentLine ? ' ' : '') + wordObj.word;
                const metrics = gCtx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine !== '') {
                    let xPos = x;
                    currentLineSegments.forEach(segment => {
                        gCtx.fillStyle = segment.type === 'link' ? '#FFA500' : 'rgba(255, 255, 255, 0.8)';
                        gCtx.fillText(segment.text, xPos, y);
                        
                        if (segment.type === 'link') {
                            const linkWidth = gCtx.measureText(segment.text).width;
                            activeButtonLinks.push({
                                x: xPos,
                                y,
                                width: linkWidth,
                                height: parseInt(gCtx.font),
                                url: segment.url
                            });
                        }
                        xPos += gCtx.measureText(segment.text).width;
                    });
                    
                    y += isMobileDevice() ? 28 : 22;
                    currentLine = wordObj.word;
                    currentLineSegments = [{
                        text: wordObj.word,
                        type: wordObj.type,
                        url: wordObj.url
                    }];
                } else {
                    currentLine = testLine;
                    if (currentLineSegments.length > 0 && 
                        currentLineSegments[currentLineSegments.length - 1].type === wordObj.type) {
                        currentLineSegments[currentLineSegments.length - 1].text += ' ' + wordObj.word;
                    } else {
                        currentLineSegments.push({
                            text: (currentLineSegments.length ? ' ' : '') + wordObj.word,
                            type: wordObj.type,
                            url: wordObj.url
                        });
                    }
                }
            }
            
            if (currentLineSegments.length > 0) {
                let xPos = x;
                currentLineSegments.forEach(segment => {
                    gCtx.fillStyle = segment.type === 'link' ? '#FFA500' : 'rgba(255, 255, 255, 0.8)';
                    gCtx.fillText(segment.text, xPos, y);
                    
                    if (segment.type === 'link') {
                        const linkWidth = gCtx.measureText(segment.text).width;
                        activeButtonLinks.push({
                            x: xPos,
                            y,
                            width: linkWidth,
                            height: parseInt(gCtx.font),
                            url: segment.url
                        });
                    }
                    xPos += gCtx.measureText(segment.text).width;
                });
            }
            
            const contentHeight = y - textY + (isMobileDevice() ? 28 : 22) + padding;
            
            gCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            gCtx.fillRect(offsetX, textY, textWidth, contentHeight);
            gCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            gCtx.strokeRect(offsetX, textY, textWidth, contentHeight);
            
            const performanceModeDiv = document.querySelector('div:has(#performanceMode)');
            performanceModeDiv.style.left = offsetX + 'px';
            performanceModeDiv.style.top = (textY + contentHeight + 20) + 'px';
        }

        window.addEventListener('resize', () => {
            resize();
            
            if (activeButton) {
                const { gridSize, offsetX, offsetY } = getGameDimensions();
                const buttonRowY = offsetY + gridSize + 20;
                const squareButtonSize = 45;
                const textY = buttonRowY + squareButtonSize + 20;
                const textWidth = gridSize;
                
                drawButtonContent(activeButton, offsetX, textY, textWidth);
            }
        });

        function hasAnyPossibleMoves() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === 0) return true;
                }
            }
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const value = grid[y][x];
                    
                    if (x < GRID_SIZE - 1 && grid[y][x + 1] === value) return true;
                    if (y < GRID_SIZE - 1 && grid[y + 1][x] === value) return true;
                }
            }
            
            return false;
        }
    </script>
</body>
</html>